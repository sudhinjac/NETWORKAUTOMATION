# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_global_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__global_interface_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /global-interface-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Global scoped configuration for interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__link_status',)

  _yang_name = 'global-interface-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__link_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'disable': {'value': 1}, 'software-interfaces': {'value': 2}},), default=six.text_type("default"), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Link-status-enum', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['global-interface-configuration']

  def _get_link_status(self):
    """
    Getter method for link_status, mapped from YANG variable /global_interface_configuration/link_status (Link-status-enum)

    YANG Description: Enable or disable link-status messages
    """
    return self.__link_status
      
  def _set_link_status(self, v, load=False):
    """
    Setter method for link_status, mapped from YANG variable /global_interface_configuration/link_status (Link-status-enum)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_status() directly.

    YANG Description: Enable or disable link-status messages
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'disable': {'value': 1}, 'software-interfaces': {'value': 2}},), default=six.text_type("default"), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Link-status-enum', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_status must be of a type compatible with Link-status-enum""",
          'defined-type': "Cisco-IOS-XR-ifmgr-cfg:Link-status-enum",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'disable': {'value': 1}, 'software-interfaces': {'value': 2}},), default=six.text_type("default"), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Link-status-enum', is_config=True)""",
        })

    self.__link_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_status(self):
    self.__link_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'disable': {'value': 1}, 'software-interfaces': {'value': 2}},), default=six.text_type("default"), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Link-status-enum', is_config=True)

  link_status = __builtin__.property(_get_link_status, _set_link_status)


  _pyangbind_elements = OrderedDict([('link_status', link_status), ])


class yc_dampening_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_dampening(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/dampening. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Whether this interface's state changes are
dampened or not
  """
  __slots__ = ('_path_helper', '_extmethods', '__args','__half_life','__reuse_threshold','__suppress_threshold','__suppress_time','__restart_penalty',)

  _yang_name = 'dampening'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__args = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default-values': {'value': 0}, 'specify-half-life': {'value': 1}, 'specify-all': {'value': 4}, 'specify-rp': {'value': 5}},), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='enumeration', is_config=True)
    self.__half_life = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    self.__reuse_threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    self.__suppress_threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    self.__suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    self.__restart_penalty = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'dampening']

  def _get_args(self):
    """
    Getter method for args, mapped from YANG variable /interface_configurations/interface_configuration/dampening/args (enumeration)

    YANG Description: Dampening Arguments
    """
    return self.__args
      
  def _set_args(self, v, load=False):
    """
    Setter method for args, mapped from YANG variable /interface_configurations/interface_configuration/dampening/args (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_args is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_args() directly.

    YANG Description: Dampening Arguments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default-values': {'value': 0}, 'specify-half-life': {'value': 1}, 'specify-all': {'value': 4}, 'specify-rp': {'value': 5}},), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """args must be of a type compatible with enumeration""",
          'defined-type': "Cisco-IOS-XR-ifmgr-cfg:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default-values': {'value': 0}, 'specify-half-life': {'value': 1}, 'specify-all': {'value': 4}, 'specify-rp': {'value': 5}},), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='enumeration', is_config=True)""",
        })

    self.__args = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_args(self):
    self.__args = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default-values': {'value': 0}, 'specify-half-life': {'value': 1}, 'specify-all': {'value': 4}, 'specify-rp': {'value': 5}},), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='enumeration', is_config=True)


  def _get_half_life(self):
    """
    Getter method for half_life, mapped from YANG variable /interface_configurations/interface_configuration/dampening/half_life (uint32)

    YANG Description: Decay half life (in minutes)
    """
    return self.__half_life
      
  def _set_half_life(self, v, load=False):
    """
    Setter method for half_life, mapped from YANG variable /interface_configurations/interface_configuration/dampening/half_life (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_half_life is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_half_life() directly.

    YANG Description: Decay half life (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """half_life must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__half_life = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_half_life(self):
    self.__half_life = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="half-life", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)


  def _get_reuse_threshold(self):
    """
    Getter method for reuse_threshold, mapped from YANG variable /interface_configurations/interface_configuration/dampening/reuse_threshold (uint32)

    YANG Description: Reuse threshold
    """
    return self.__reuse_threshold
      
  def _set_reuse_threshold(self, v, load=False):
    """
    Setter method for reuse_threshold, mapped from YANG variable /interface_configurations/interface_configuration/dampening/reuse_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse_threshold() directly.

    YANG Description: Reuse threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__reuse_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse_threshold(self):
    self.__reuse_threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)


  def _get_suppress_threshold(self):
    """
    Getter method for suppress_threshold, mapped from YANG variable /interface_configurations/interface_configuration/dampening/suppress_threshold (uint32)

    YANG Description: Suppress threshold
    """
    return self.__suppress_threshold
      
  def _set_suppress_threshold(self, v, load=False):
    """
    Setter method for suppress_threshold, mapped from YANG variable /interface_configurations/interface_configuration/dampening/suppress_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_threshold() directly.

    YANG Description: Suppress threshold
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__suppress_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_threshold(self):
    self.__suppress_threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)


  def _get_suppress_time(self):
    """
    Getter method for suppress_time, mapped from YANG variable /interface_configurations/interface_configuration/dampening/suppress_time (uint32)

    YANG Description: Max suppress time (in minutes)
    """
    return self.__suppress_time
      
  def _set_suppress_time(self, v, load=False):
    """
    Setter method for suppress_time, mapped from YANG variable /interface_configurations/interface_configuration/dampening/suppress_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_time() directly.

    YANG Description: Max suppress time (in minutes)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_time(self):
    self.__suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)


  def _get_restart_penalty(self):
    """
    Getter method for restart_penalty, mapped from YANG variable /interface_configurations/interface_configuration/dampening/restart_penalty (uint32)

    YANG Description: Restart penalty
    """
    return self.__restart_penalty
      
  def _set_restart_penalty(self, v, load=False):
    """
    Setter method for restart_penalty, mapped from YANG variable /interface_configurations/interface_configuration/dampening/restart_penalty (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_penalty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_penalty() directly.

    YANG Description: Restart penalty
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_penalty must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__restart_penalty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_penalty(self):
    self.__restart_penalty = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..20000']}), is_leaf=True, yang_name="restart-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

  args = __builtin__.property(_get_args, _set_args)
  half_life = __builtin__.property(_get_half_life, _set_half_life)
  reuse_threshold = __builtin__.property(_get_reuse_threshold, _set_reuse_threshold)
  suppress_threshold = __builtin__.property(_get_suppress_threshold, _set_suppress_threshold)
  suppress_time = __builtin__.property(_get_suppress_time, _set_suppress_time)
  restart_penalty = __builtin__.property(_get_restart_penalty, _set_restart_penalty)


  _pyangbind_elements = OrderedDict([('args', args), ('half_life', half_life), ('reuse_threshold', reuse_threshold), ('suppress_threshold', suppress_threshold), ('suppress_time', suppress_time), ('restart_penalty', restart_penalty), ])


class yc_mtu_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus_mtu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/mtus/mtu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The MTU for the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__owner','__mtu',)

  _yang_name = 'mtu'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__owner = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'mtus', 'mtu']

  def _get_owner(self):
    """
    Getter method for owner, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu/owner (xr:Cisco-ios-xr-string)

    YANG Description: The Owner of the interface - eg. for
'LoopbackX' main interface this is 'loopback'
    """
    return self.__owner
      
  def _set_owner(self, v, load=False):
    """
    Setter method for owner, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu/owner (xr:Cisco-ios-xr-string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_owner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_owner() directly.

    YANG Description: The Owner of the interface - eg. for
'LoopbackX' main interface this is 'loopback'
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """owner must be of a type compatible with xr:Cisco-ios-xr-string""",
          'defined-type': "xr:Cisco-ios-xr-string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)""",
        })

    self.__owner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_owner(self):
    self.__owner = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[\\w\\-\\.:,_@#%$\\+=\\|;]+'}), is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Cisco-ios-xr-string', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu/mtu (uint32)

    YANG Description: The MTU value
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The MTU value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64..65535']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

  owner = __builtin__.property(_get_owner, _set_owner)
  mtu = __builtin__.property(_get_mtu, _set_mtu)


  _pyangbind_elements = OrderedDict([('owner', owner), ('mtu', mtu), ])


class yc_mtus_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/mtus. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The MTU configuration for the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__mtu',)

  _yang_name = 'mtus'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mtu = YANGDynClass(base=YANGListType("owner",yc_mtu_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus_mtu, yang_name="mtu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='owner', extensions=None), is_container='list', yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'mtus']

  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu (list)

    YANG Description: The MTU for the interface
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /interface_configurations/interface_configuration/mtus/mtu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: The MTU for the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("owner",yc_mtu_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus_mtu, yang_name="mtu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='owner', extensions=None), is_container='list', yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("owner",yc_mtu_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus_mtu, yang_name="mtu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='owner', extensions=None), is_container='list', yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=YANGListType("owner",yc_mtu_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus_mtu, yang_name="mtu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='owner', extensions=None), is_container='list', yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)

  mtu = __builtin__.property(_get_mtu, _set_mtu)


  _pyangbind_elements = OrderedDict([('mtu', mtu), ])


class yc_encapsulation_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_encapsulation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration/encapsulation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The encapsulation on the interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__encapsulation','__capsulation_options',)

  _yang_name = 'encapsulation'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__encapsulation = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)
    self.__capsulation_options = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="capsulation-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration', 'encapsulation']

  def _get_encapsulation(self):
    """
    Getter method for encapsulation, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation/encapsulation (string)

    YANG Description: The encapsulation - e.g. hdlc, ppp
    """
    return self.__encapsulation
      
  def _set_encapsulation(self, v, load=False):
    """
    Setter method for encapsulation, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation/encapsulation (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation() directly.

    YANG Description: The encapsulation - e.g. hdlc, ppp
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)""",
        })

    self.__encapsulation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation(self):
    self.__encapsulation = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)


  def _get_capsulation_options(self):
    """
    Getter method for capsulation_options, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation/capsulation_options (uint32)

    YANG Description: The options for this capsulation, usually '0'
    """
    return self.__capsulation_options
      
  def _set_capsulation_options(self, v, load=False):
    """
    Setter method for capsulation_options, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation/capsulation_options (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capsulation_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capsulation_options() directly.

    YANG Description: The options for this capsulation, usually '0'
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="capsulation-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capsulation_options must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="capsulation-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__capsulation_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capsulation_options(self):
    self.__capsulation_options = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="capsulation-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)

  encapsulation = __builtin__.property(_get_encapsulation, _set_encapsulation)
  capsulation_options = __builtin__.property(_get_capsulation_options, _set_capsulation_options)


  _pyangbind_elements = OrderedDict([('encapsulation', encapsulation), ('capsulation_options', capsulation_options), ])


class yc_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations/interface-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The configuration for an interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__dampening','__mtus','__encapsulation','__shutdown','__interface_virtual','__secondary_admin_state','__interface_mode_non_physical','__bandwidth','__link_status','__description','__active','__interface_name',)

  _yang_name = 'interface-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dampening = YANGDynClass(base=yc_dampening_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    self.__mtus = YANGDynClass(base=yc_mtus_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus, is_container='container', yang_name="mtus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    self.__encapsulation = YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    self.__shutdown = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    self.__interface_virtual = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="interface-virtual", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    self.__secondary_admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'maintenance': {'value': 1}},), is_leaf=True, yang_name="secondary-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Secondary-admin-state-enum', is_config=True)
    self.__interface_mode_non_physical = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'point-to-point': {'value': 1}, 'multipoint': {'value': 2}, 'l2-transport': {'value': 3}},), default=six.text_type("default"), is_leaf=True, yang_name="interface-mode-non-physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-mode-enum', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    self.__link_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)
    self.__active = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(act)|(pre)'}), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-active', is_config=True)
    self.__interface_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Interface-name', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations', 'interface-configuration']

  def _get_dampening(self):
    """
    Getter method for dampening, mapped from YANG variable /interface_configurations/interface_configuration/dampening (container)

    YANG Description: Whether this interface's state changes are
dampened or not
    """
    return self.__dampening
      
  def _set_dampening(self, v, load=False):
    """
    Setter method for dampening, mapped from YANG variable /interface_configurations/interface_configuration/dampening (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dampening is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dampening() directly.

    YANG Description: Whether this interface's state changes are
dampened or not
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dampening_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dampening must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dampening_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)""",
        })

    self.__dampening = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dampening(self):
    self.__dampening = YANGDynClass(base=yc_dampening_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_dampening, is_container='container', yang_name="dampening", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)


  def _get_mtus(self):
    """
    Getter method for mtus, mapped from YANG variable /interface_configurations/interface_configuration/mtus (container)

    YANG Description: The MTU configuration for the interface
    """
    return self.__mtus
      
  def _set_mtus(self, v, load=False):
    """
    Setter method for mtus, mapped from YANG variable /interface_configurations/interface_configuration/mtus (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtus() directly.

    YANG Description: The MTU configuration for the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mtus_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus, is_container='container', yang_name="mtus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtus must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mtus_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus, is_container='container', yang_name="mtus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)""",
        })

    self.__mtus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtus(self):
    self.__mtus = YANGDynClass(base=yc_mtus_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_mtus, is_container='container', yang_name="mtus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)


  def _get_encapsulation(self):
    """
    Getter method for encapsulation, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation (container)

    YANG Description: The encapsulation on the interface
    """
    return self.__encapsulation
      
  def _set_encapsulation(self, v, load=False):
    """
    Setter method for encapsulation, mapped from YANG variable /interface_configurations/interface_configuration/encapsulation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation() directly.

    YANG Description: The encapsulation on the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_encapsulation_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)""",
        })

    self.__encapsulation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation(self):
    self.__encapsulation = YANGDynClass(base=yc_encapsulation_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration_encapsulation, is_container='container', yang_name="encapsulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)


  def _get_shutdown(self):
    """
    Getter method for shutdown, mapped from YANG variable /interface_configurations/interface_configuration/shutdown (empty)

    YANG Description: The existence of this configuration indicates
the interface is shut down
    """
    return self.__shutdown
      
  def _set_shutdown(self, v, load=False):
    """
    Setter method for shutdown, mapped from YANG variable /interface_configurations/interface_configuration/shutdown (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown() directly.

    YANG Description: The existence of this configuration indicates
the interface is shut down
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)""",
        })

    self.__shutdown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown(self):
    self.__shutdown = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)


  def _get_interface_virtual(self):
    """
    Getter method for interface_virtual, mapped from YANG variable /interface_configurations/interface_configuration/interface_virtual (empty)

    YANG Description: The mode in which an interface is running. The
existence of this object causes the creation of
the software virtual/subinterface.
    """
    return self.__interface_virtual
      
  def _set_interface_virtual(self, v, load=False):
    """
    Setter method for interface_virtual, mapped from YANG variable /interface_configurations/interface_configuration/interface_virtual (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_virtual is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_virtual() directly.

    YANG Description: The mode in which an interface is running. The
existence of this object causes the creation of
the software virtual/subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="interface-virtual", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_virtual must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="interface-virtual", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)""",
        })

    self.__interface_virtual = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_virtual(self):
    self.__interface_virtual = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="interface-virtual", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)


  def _get_secondary_admin_state(self):
    """
    Getter method for secondary_admin_state, mapped from YANG variable /interface_configurations/interface_configuration/secondary_admin_state (Secondary-admin-state-enum)

    YANG Description: The secondary admin state of the interface
    """
    return self.__secondary_admin_state
      
  def _set_secondary_admin_state(self, v, load=False):
    """
    Setter method for secondary_admin_state, mapped from YANG variable /interface_configurations/interface_configuration/secondary_admin_state (Secondary-admin-state-enum)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_admin_state() directly.

    YANG Description: The secondary admin state of the interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'maintenance': {'value': 1}},), is_leaf=True, yang_name="secondary-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Secondary-admin-state-enum', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_admin_state must be of a type compatible with Secondary-admin-state-enum""",
          'defined-type': "Cisco-IOS-XR-ifmgr-cfg:Secondary-admin-state-enum",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'maintenance': {'value': 1}},), is_leaf=True, yang_name="secondary-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Secondary-admin-state-enum', is_config=True)""",
        })

    self.__secondary_admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_admin_state(self):
    self.__secondary_admin_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'maintenance': {'value': 1}},), is_leaf=True, yang_name="secondary-admin-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Secondary-admin-state-enum', is_config=True)


  def _get_interface_mode_non_physical(self):
    """
    Getter method for interface_mode_non_physical, mapped from YANG variable /interface_configurations/interface_configuration/interface_mode_non_physical (Interface-mode-enum)

    YANG Description: The mode in which an interface is running. The
existence of this object causes the creation of
the software subinterface.
    """
    return self.__interface_mode_non_physical
      
  def _set_interface_mode_non_physical(self, v, load=False):
    """
    Setter method for interface_mode_non_physical, mapped from YANG variable /interface_configurations/interface_configuration/interface_mode_non_physical (Interface-mode-enum)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_mode_non_physical is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_mode_non_physical() directly.

    YANG Description: The mode in which an interface is running. The
existence of this object causes the creation of
the software subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'point-to-point': {'value': 1}, 'multipoint': {'value': 2}, 'l2-transport': {'value': 3}},), default=six.text_type("default"), is_leaf=True, yang_name="interface-mode-non-physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-mode-enum', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_mode_non_physical must be of a type compatible with Interface-mode-enum""",
          'defined-type': "Cisco-IOS-XR-ifmgr-cfg:Interface-mode-enum",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'point-to-point': {'value': 1}, 'multipoint': {'value': 2}, 'l2-transport': {'value': 3}},), default=six.text_type("default"), is_leaf=True, yang_name="interface-mode-non-physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-mode-enum', is_config=True)""",
        })

    self.__interface_mode_non_physical = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_mode_non_physical(self):
    self.__interface_mode_non_physical = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 0}, 'point-to-point': {'value': 1}, 'multipoint': {'value': 2}, 'l2-transport': {'value': 3}},), default=six.text_type("default"), is_leaf=True, yang_name="interface-mode-non-physical", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-mode-enum', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /interface_configurations/interface_configuration/bandwidth (uint32)

    YANG Description: The bandwidth of the interface in kbps
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /interface_configurations/interface_configuration/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: The bandwidth of the interface in kbps
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='uint32', is_config=True)


  def _get_link_status(self):
    """
    Getter method for link_status, mapped from YANG variable /interface_configurations/interface_configuration/link_status (empty)

    YANG Description: Enable interface and line-protocol state change
alarms
    """
    return self.__link_status
      
  def _set_link_status(self, v, load=False):
    """
    Setter method for link_status, mapped from YANG variable /interface_configurations/interface_configuration/link_status (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_status() directly.

    YANG Description: Enable interface and line-protocol state change
alarms
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_status must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)""",
        })

    self.__link_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_status(self):
    self.__link_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='empty', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /interface_configurations/interface_configuration/description (string)

    YANG Description: The description of this interface
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /interface_configurations/interface_configuration/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: The description of this interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='string', is_config=True)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /interface_configurations/interface_configuration/active (Interface-active)

    YANG Description: Whether the interface is active or
preconfigured
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /interface_configurations/interface_configuration/active (Interface-active)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Whether the interface is active or
preconfigured
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(act)|(pre)'}), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-active', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with Interface-active""",
          'defined-type': "Cisco-IOS-XR-ifmgr-cfg:Interface-active",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(act)|(pre)'}), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-active', is_config=True)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(act)|(pre)'}), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='Interface-active', is_config=True)


  def _get_interface_name(self):
    """
    Getter method for interface_name, mapped from YANG variable /interface_configurations/interface_configuration/interface_name (xr:Interface-name)

    YANG Description: The name of the interface
    """
    return self.__interface_name
      
  def _set_interface_name(self, v, load=False):
    """
    Setter method for interface_name, mapped from YANG variable /interface_configurations/interface_configuration/interface_name (xr:Interface-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_name() directly.

    YANG Description: The name of the interface
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Interface-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_name must be of a type compatible with xr:Interface-name""",
          'defined-type': "xr:Interface-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Interface-name', is_config=True)""",
        })

    self.__interface_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_name(self):
    self.__interface_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z0-9.:_/-]+'}), is_leaf=True, yang_name="interface-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='xr:Interface-name', is_config=True)

  dampening = __builtin__.property(_get_dampening, _set_dampening)
  mtus = __builtin__.property(_get_mtus, _set_mtus)
  encapsulation = __builtin__.property(_get_encapsulation, _set_encapsulation)
  shutdown = __builtin__.property(_get_shutdown, _set_shutdown)
  interface_virtual = __builtin__.property(_get_interface_virtual, _set_interface_virtual)
  secondary_admin_state = __builtin__.property(_get_secondary_admin_state, _set_secondary_admin_state)
  interface_mode_non_physical = __builtin__.property(_get_interface_mode_non_physical, _set_interface_mode_non_physical)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  link_status = __builtin__.property(_get_link_status, _set_link_status)
  description = __builtin__.property(_get_description, _set_description)
  active = __builtin__.property(_get_active, _set_active)
  interface_name = __builtin__.property(_get_interface_name, _set_interface_name)


  _pyangbind_elements = OrderedDict([('dampening', dampening), ('mtus', mtus), ('encapsulation', encapsulation), ('shutdown', shutdown), ('interface_virtual', interface_virtual), ('secondary_admin_state', secondary_admin_state), ('interface_mode_non_physical', interface_mode_non_physical), ('bandwidth', bandwidth), ('link_status', link_status), ('description', description), ('active', active), ('interface_name', interface_name), ])


class yc_interface_configurations_Cisco_IOS_XR_ifmgr_cfg__interface_configurations(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /interface-configurations. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for all interfaces
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface_configuration',)

  _yang_name = 'interface-configurations'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface_configuration = YANGDynClass(base=YANGListType("active interface_name",yc_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration, yang_name="interface-configuration", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='active interface-name', extensions=None), is_container='list', yang_name="interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interface-configurations']

  def _get_interface_configuration(self):
    """
    Getter method for interface_configuration, mapped from YANG variable /interface_configurations/interface_configuration (list)

    YANG Description: The configuration for an interface
    """
    return self.__interface_configuration
      
  def _set_interface_configuration(self, v, load=False):
    """
    Setter method for interface_configuration, mapped from YANG variable /interface_configurations/interface_configuration (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_configuration() directly.

    YANG Description: The configuration for an interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("active interface_name",yc_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration, yang_name="interface-configuration", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='active interface-name', extensions=None), is_container='list', yang_name="interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_configuration must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("active interface_name",yc_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration, yang_name="interface-configuration", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='active interface-name', extensions=None), is_container='list', yang_name="interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)""",
        })

    self.__interface_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_configuration(self):
    self.__interface_configuration = YANGDynClass(base=YANGListType("active interface_name",yc_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__interface_configurations_interface_configuration, yang_name="interface-configuration", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='active interface-name', extensions=None), is_container='list', yang_name="interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='list', is_config=True)

  interface_configuration = __builtin__.property(_get_interface_configuration, _set_interface_configuration)


  _pyangbind_elements = OrderedDict([('interface_configuration', interface_configuration), ])


class Cisco_IOS_XR_ifmgr_cfg(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-ifmgr-cfg - based on the path /Cisco-IOS-XR-ifmgr-cfg. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG definitions
for Cisco IOS-XR ifmgr package configuration.

This module contains definitions
for the following management objects:
  global-interface-configuration: Global scoped configuration
    for interfaces
  interface-configurations: Configuration for all interfaces

Copyright (c) 2013-2019 by Cisco Systems, Inc.
All rights reserved.
  """
  __slots__ = ('_path_helper', '_extmethods', '__global_interface_configuration','__interface_configurations',)

  _yang_name = 'Cisco-IOS-XR-ifmgr-cfg'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__global_interface_configuration = YANGDynClass(base=yc_global_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__global_interface_configuration, is_container='container', yang_name="global-interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    self.__interface_configurations = YANGDynClass(base=yc_interface_configurations_Cisco_IOS_XR_ifmgr_cfg__interface_configurations, is_container='container', yang_name="interface-configurations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_global_interface_configuration(self):
    """
    Getter method for global_interface_configuration, mapped from YANG variable /global_interface_configuration (container)

    YANG Description: Global scoped configuration for interfaces
    """
    return self.__global_interface_configuration
      
  def _set_global_interface_configuration(self, v, load=False):
    """
    Setter method for global_interface_configuration, mapped from YANG variable /global_interface_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_interface_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_interface_configuration() directly.

    YANG Description: Global scoped configuration for interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_global_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__global_interface_configuration, is_container='container', yang_name="global-interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_interface_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_global_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__global_interface_configuration, is_container='container', yang_name="global-interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)""",
        })

    self.__global_interface_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_interface_configuration(self):
    self.__global_interface_configuration = YANGDynClass(base=yc_global_interface_configuration_Cisco_IOS_XR_ifmgr_cfg__global_interface_configuration, is_container='container', yang_name="global-interface-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)


  def _get_interface_configurations(self):
    """
    Getter method for interface_configurations, mapped from YANG variable /interface_configurations (container)

    YANG Description: Configuration for all interfaces
    """
    return self.__interface_configurations
      
  def _set_interface_configurations(self, v, load=False):
    """
    Setter method for interface_configurations, mapped from YANG variable /interface_configurations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_configurations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_configurations() directly.

    YANG Description: Configuration for all interfaces
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interface_configurations_Cisco_IOS_XR_ifmgr_cfg__interface_configurations, is_container='container', yang_name="interface-configurations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_configurations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interface_configurations_Cisco_IOS_XR_ifmgr_cfg__interface_configurations, is_container='container', yang_name="interface-configurations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)""",
        })

    self.__interface_configurations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_configurations(self):
    self.__interface_configurations = YANGDynClass(base=yc_interface_configurations_Cisco_IOS_XR_ifmgr_cfg__interface_configurations, is_container='container', yang_name="interface-configurations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg', defining_module='Cisco-IOS-XR-ifmgr-cfg', yang_type='container', is_config=True)

  global_interface_configuration = __builtin__.property(_get_global_interface_configuration, _set_global_interface_configuration)
  interface_configurations = __builtin__.property(_get_interface_configurations, _set_interface_configurations)


  _pyangbind_elements = OrderedDict([('global_interface_configuration', global_interface_configuration), ('interface_configurations', interface_configurations), ])


class Cisco_IOS_XR_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module Cisco-IOS-XR-types - based on the path /Cisco-IOS-XR-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of IOS-XR derived YANG data
types.

Copyright (c) 2013-2019 by Cisco Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

class cisco_semver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module cisco-semver - based on the path /cisco-semver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines semantic version for Cisco defined YANG models. 
Copyright (c) 2019 by Cisco Systems, Inc.
All rights reserved.
  """
  _pyangbind_elements = {}

  

